<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>FTDC Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root {
      --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --grid:#e5e7eb;
      --border:#e2e8f0; --subtle:#f1f5f9; --chip:#334155; --chipbg:#e2e8f0; --red: #ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial}
    header{padding:16px 24px;border-bottom:1px solid var(--border);display:flex;gap:16px;align-items:center;background:var(--card)}
    h1{font-size:16px;margin:0}
    .wrap{width:100%;margin:0 auto;padding:24px;display:grid;grid-template-columns:1fr;gap:18px}
    .section{margin-top:8px}
    .sec-title{font-size:18px;font-weight:700;margin:12px 0 16px 4px;color:#0f172a;cursor:pointer;position:relative;padding-left:20px;user-select:none}
    .sec-title::before { content: '▼'; position: absolute; left: 0; top: 50%; transform: translateY(-50%); font-size: 12px; transition: transform 0.2s; }
    .sec-title.collapsed::before { transform: translateY(-50%) rotate(-90deg); }
    .grid{display:grid;grid-template-columns:1fr;gap:24px; overflow:hidden; transition: max-height 0.3s ease-in-out;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05);}
    .pane{padding:16px 16px 8px}
    .title{font-size:16px; color:#1e293b; font-weight:600; margin:0 0 12px 2px}
    .chart{width:100%;height:340px}
    .tablewrap{border-top:1px solid var(--border);background:var(--subtle); color: var(--muted); font-size: 13px;}
    .actions{display:flex;gap:8px;align-items:center;padding:10px 12px}
    .btn{border:1px solid var(--border);background:#fff;border-radius:8px;padding:6px 10px;cursor:pointer; font-size:12px;}
    .btn:hover{background:#f1f5f9}
    table{width:100%;border-collapse:collapse}
    thead th{font-weight:600;color:#111827;background:var(--subtle);border-top:1px solid var(--border);border-bottom:1px solid var(--border); font-size:12px;}
    thead th, tbody td{padding:8px 12px;border-bottom:1px solid var(--border);text-align:right;white-space:nowrap}
    thead th:first-child, tbody td:first-child{text-align:left}
    tbody tr{background:#fff;cursor:pointer}
    tbody tr.off{color:#94a3b8}
    tbody tr:hover{background:var(--subtle)}
    .namecell{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;border:1px solid rgba(0,0,0,.15)}
    .chip{font-size:12px;color:var(--chip);background:var(--chipbg);padding:2px 8px;border-radius:999px}
    .muted{color:var(--muted)}
    .sortable{cursor:pointer}
    .sortable::after{content:"";margin-left:6px;border:4px solid transparent;border-top-color:#94a3b8;display:inline-block;transform:translateY(2px)}
    .asc.sortable::after{border-top-color:transparent;border-bottom-color:#334155;transform:translateY(-2px)}
    .summary-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: stretch; overflow: hidden; transition: max-height 0.3s ease-in-out; }
    .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px; }
    .summary-section h3 { font-size: 14px; margin: 0 0 8px; color: var(--muted); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
    .summary-section ul { margin: 0; padding: 0; list-style: none; }
    .summary-section li { display: flex; justify-content: space-between; padding: 4px 0; flex-wrap: wrap; }
    .summary-section li span:first-child { font-weight: 600; color: var(--fg); margin-right: 8px; }
    .summary-section li span:last-child { color: var(--muted); text-align: right; }
    details.config-details { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
    summary.config-summary { cursor: pointer; padding: 8px 12px; font-weight: 600; background: var(--subtle); list-style: none; }
    summary.config-summary::-webkit-details-marker { display: none; }
    .config-view { margin:0; background: #0d1117; color: #c9d1d9; font-family: monospace; font-size: 13px; padding: 16px; overflow: auto; line-height: 1.6; max-height: 250px; }
    .config-change-dot { color: var(--red); margin-left: 8px; font-size: 16px; line-height: 1; display: inline-block; vertical-align: middle; }
    .repl-chart-container { background:var(--card); border:1px solid var(--border); border-radius:12px; overflow:hidden; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05); padding: 16px; }
    .repl-chart { width: 100%; }
    @media (min-width: 1200px) { .grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 1024px) { .summary-container { grid-template-columns: 1fr; } }
    @media (max-width: 768px) { .summary-grid { grid-template-columns: 1fr; } }
    @media (max-width:1000px){ .chart{height:300px} }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
<header>
  <h1>FTDC Dashboard</h1>
</header>

<div class="wrap" id="wrap"></div>

<script>
(async function () {
  const res = await fetch('/api/data');
  const data = await res.json();

  const W = document.getElementById('wrap');
  const L = data.labels;

  const totalDurationHours = (L && L.length > 1) ? (new Date(L[L.length - 1]).getTime() - new Date(L[0]).getTime()) / (1000 * 60 * 60) : 0;
  const useDailyTimeFormat = totalDurationHours > 48;

  function buildReplStatusChartContainer(timeline) {
    if (!timeline || timeline.length === 0) return null;
    
    const eventsByNode = timeline.reduce((acc, event) => {
        if (!acc[event.name]) acc[event.name] = [];
        acc[event.name].push(true);
        return acc;
    }, {});
    const nodeCount = Object.keys(eventsByNode).length;

    const container = document.createElement('div');
    container.className = 'section';
    const chartHeight = nodeCount * 40 + 60;
    container.innerHTML = `
        <div class="sec-title">Node States</div>
        <div class="repl-chart-container">
            <div class="repl-chart" style="height:${chartHeight}px"></div>
        </div>
    `;
    return container;
  }

  function initReplStatusChart(containerEl, timeline, labels) {
    if (!containerEl || !timeline || timeline.length === 0) return;

    const stateColors = {
        PRIMARY: '#6a994e', SECONDARY: '#f5b700', ARBITER: '#a2d2ff',
        RECOVERING: '#ef476f', STARTUP: '#8338ec', STARTUP2: '#8338ec',
        UNKNOWN: '#6c757d', DOWN: '#d62828', ROLLBACK: '#ff7b00',
    };
    const legendData = [];

    const eventsByNode = timeline.reduce((acc, event) => {
        if (!acc[event.name]) acc[event.name] = [];
        acc[event.name].push({ t: new Date(event.t), state: event.state });
        return acc;
    }, {});

    const nodeNames = Object.keys(eventsByNode).sort();
    const chartData = [];
    const stateSet = new Set();

    nodeNames.forEach((name, nodeIndex) => {
        const events = eventsByNode[name].sort((a, b) => a.t - b.t);
        if (events.length === 0) return;

        let segmentStartEvent = events[0];

        for (let i = 1; i < events.length; i++) {
            if (events[i].state !== segmentStartEvent.state) {
                const startTime = segmentStartEvent.t.getTime();
                const endTime = events[i].t.getTime();
                
                chartData.push({
                    name: segmentStartEvent.state,
                    value: [nodeIndex, startTime, endTime, segmentStartEvent.state]
                });
                stateSet.add(segmentStartEvent.state);
                segmentStartEvent = events[i];
            }
        }

        const lastSegmentStartTime = segmentStartEvent.t.getTime();
        const lastSegmentEndTime = new Date(labels[labels.length - 1]).getTime();
        chartData.push({
            name: segmentStartEvent.state,
            value: [nodeIndex, lastSegmentStartTime, lastSegmentEndTime, segmentStartEvent.state]
        });
        stateSet.add(segmentStartEvent.state);
    });

    for(const state of stateSet) {
        legendData.push({name: state, itemStyle: {color: stateColors[state] || '#ced4da'}});
    }
    
    const chartDom = containerEl.querySelector('.repl-chart');
    const myChart = echarts.init(chartDom);

    function renderItem(params, api) {
        const categoryIndex = api.value(0);
        const start = api.coord([api.value(1), categoryIndex]);
        const end = api.coord([api.value(2), categoryIndex]);
        const height = api.size([0, 1])[1];
        const state = api.value(3);
        if (!start || !end) return;

        const rectShape = echarts.graphic.clipRectByRect({
            x: start[0],
            y: start[1] - height / 2,
            width: end[0] - start[0],
            height: height
        }, {
            x: params.coordSys.x,
            y: params.coordSys.y,
            width: params.coordSys.width,
            height: params.coordSys.height
        });

        return rectShape && {
            type: 'rect',
            transition: ['shape'],
            shape: rectShape,
            style: {
                fill: stateColors[state] || '#ced4da',
                text: state,
                textFill: '#fff',
                textPosition: 'inside',
                fontWeight: 'bold',
                fontSize: 10,
            }
        };
    }

    const option = {
        tooltip: {
            formatter: function (params) {
                const state = params.value[3];
                const start = new Date(params.value[1]).toLocaleString();
                const end = new Date(params.value[2]).toLocaleString();
                return `${nodeNames[params.value[0]]}<br/><b>${state}</b><br/>${start} - ${end}`;
            }
        },
        legend: {
          show: true, data: legendData, bottom: 0, type: 'scroll'
        },
        grid: {
            height: nodeNames.length * 40, top: 20, bottom: 60,
            left: 20, right: 50, containLabel: true,
        },
        xAxis: {
            type: 'time',
            min: new Date(labels[0]).getTime(),
            max: new Date(labels[labels.length - 1]).getTime(),
            axisLabel: { formatter: useDailyTimeFormat ? '{MM}-{dd}' : '{HH}:{mm}' }
        },
        yAxis: {
            type: 'category', data: nodeNames, axisLabel: { interval: 0 }
        },
        series: [{
            type: 'custom', renderItem: renderItem, itemStyle: { opacity: 0.9 },
            encode: { x: [1, 2], y: 0 }, data: chartData
        }]
    };
    myChart.setOption(option);
  }

  const getConfigVal = (path, fallback = 'N/A') => {
    try {
      const value = path.split('.').reduce((o, k) => o[k], data.config);
      if (typeof value === 'object' && value !== null) {
        if ('$numberInt' in value) return value['$numberInt'];
        if ('$numberLong' in value) return value['$numberLong'];
      }
      return value ?? fallback;
    } catch (e) {
      return fallback;
    }
  };

  function buildSummaryViewer(config, configChanged) {
    if (!config) return null;

    const section = document.createElement('div');
    section.className = 'section';
    
    const title = document.createElement('div');
    title.className = 'sec-title';
    title.textContent = 'Host & Configuration Summary';
    
    const content = document.createElement('div');
    content.className = 'summary-container'; 

    content.innerHTML = `
      <div class="summary-grid">
        <div class="summary-section">
          <h3>Version & Build</h3>
          <ul>
            <li><span>Hostname:</span> <span>${getConfigVal('hostInfo.system.hostname')}</span></li>
            <li><span>Mongo Version:</span> <span>${getConfigVal('buildInfo.version')} (${(getConfigVal('buildInfo.modules.0', 'community'))})</span></li>
            <li><span>OS:</span> <span>${getConfigVal('hostInfo.os.name')}</span></li>
            <li><span>Git Version:</span> <span>${getConfigVal('buildInfo.gitVersion')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Network & Replication</h3>
          <ul>
            <li><span>IP Addresses:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.bindIp')}</span></li>
            <li><span>Port:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.port')}</span></li>
            <li><span>Replica Set:</span> <span>${getConfigVal('getCmdLineOpts.parsed.replication.replSetName', 'Not in a replicaset')}</span></li>
            <li><span>Security:</span> <span>${getConfigVal('getCmdLineOpts.parsed.security.clusterAuthMode', 'N/A')}</span></li>
            <li><span>TLS Mode:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.tls.mode', 'disabled')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Storage & Logging</h3>
          <ul>
            <li><span>Data Path (dbPath):</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.dbPath')}</span></li>
            <li><span>Log Path:</span> <span>${getConfigVal('getCmdLineOpts.parsed.systemLog.path')}</span></li>
            <li><span>Journaling:</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.journal.enabled', 'false')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Server & Limits</h3>
          <ul>
            <li><span>CPU:</span> <span>${getConfigVal('hostInfo.system.numCores')} Cores</span></li>
            <li><span>CPU Arch:</span> <span>${getConfigVal('hostInfo.system.cpuArch')}</span></li>
            <li><span>RAM:</span> <span>${getConfigVal('hostInfo.system.memSizeMB')} MB</span></li>
            <li><span>Open Files Limit:</span> <span>${getConfigVal('ulimits.fileDescriptors.soft')}</span></li>
          </ul>
        </div>
      </div>
      <div>
        <details class="config-details">
          <summary class="config-summary">
            Active Configuration (parsed)
            ${configChanged ? '<span class="config-change-dot" title="Configuration changed during this period">●</span>' : ''}
          </summary>
          <pre class="config-view">${JSON.stringify(getConfigVal('getCmdLineOpts.parsed', {}), null, 2)}</pre>
        </details>
      </div>
    `;

    section.appendChild(title);
    section.appendChild(content);

    title.addEventListener('click', () => {
      title.classList.toggle('collapsed');
      const isCollapsed = title.classList.contains('collapsed');
      content.style.maxHeight = isCollapsed ? '0px' : (content.scrollHeight + 'px');
    });

    return section;
  }
  
  const summaryEl = buildSummaryViewer(data.config, data.config_changed);
  if (summaryEl) {
    W.appendChild(summaryEl);
    const content = summaryEl.querySelector('.summary-container');
    if (content) {
      content.style.maxHeight = content.scrollHeight + 'px';
    }
  }

  const replChartContainerEl = buildReplStatusChartContainer(data.repl_timeline);
  if (replChartContainerEl) {
    W.appendChild(replChartContainerEl);
    initReplStatusChart(replChartContainerEl, data.repl_timeline, data.labels);
  }

  function stats(arr){
    const vals = (arr||[]).filter(v => typeof v === 'number' && !Number.isNaN(v));
    if (!vals.length) return {min:null,max:null,avg:null,p95:null};
    vals.sort((a, b) => a - b);
    const p95Index = Math.floor(vals.length * 0.95);
    const p95 = vals[p95Index];
    let min=vals[0], max=vals[vals.length - 1], sum=0;
    for (const v of vals){ sum+=v; }
    return {min, max, avg: sum/vals.length, p95};
  }

  function fmt(v){
    if (v == null || typeof v !== 'number' || Number.isNaN(v)) return '—';
    return v.toFixed(2);
  }

  function buildSection(title){ 
    const s = document.createElement('div'); 
    s.className='section';
    const secTitle = document.createElement('div');
    secTitle.className = 'sec-title';
    secTitle.textContent = title;
    const grid = document.createElement('div');
    grid.className = 'grid';
    s.appendChild(secTitle);
    s.appendChild(grid);
    W.appendChild(s);

    secTitle.addEventListener('click', () => {
      secTitle.classList.toggle('collapsed');
      const isCollapsed = secTitle.classList.contains('collapsed');
      grid.style.maxHeight = isCollapsed ? '0px' : (grid.scrollHeight + 'px');
    });
    return grid; 
  }

  function getDisplayName(key, title) {
      if (title.toLowerCase().includes('disk')) {
        const parts = key.split('_');
        const device = parts[parts.length - 1];
        if (key.includes('_read_')) return `${device} (read)`;
        if (key.includes('_write_')) return `${device} (write)`;
        return device;
      }
      if (key.startsWith('wt_pages_evicted_')) {
        return key.includes('_modified_') ? 'modified' : 'unmodified';
      }
      return key;
  }

  function buildCard(grid, title, seriesKeys, unit){
    if (!seriesKeys || !seriesKeys.some(k => data.series[k])) return;
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<div class="pane"><div class="title">${title}</div><div class="chart"></div></div><div class="tablewrap"><div class="actions"><span class="chip">series</span><button class="btn" data-act="all">All</button><button class="btn" data-act="none">None</button><button class="btn" data-act="inverse">Inverse</button></div><table class="tbl"><thead><tr><th class="sortable asc" data-k="name">name</th><th class="sortable" data-k="min">min</th><th class="sortable" data-k="avg">avg</th><th class="sortable" data-k="max">max</th><th class="sortable" data-k="p95">p95</th></tr></thead><tbody></tbody></table></div>`;
    grid.appendChild(card);
    
    const chartLabels = L.map(ts => new Date(ts));

    const chart = echarts.init(card.querySelector('.chart'), 'light', {renderer:'canvas'});
    const palette = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#0ea5e9','#f97316','#22c55e','#e11d48','#10b981','#a855f7','#84cc16'];
    const legendSelected = {};
    const series = seriesKeys.map((key, i) => {
      const displayName = getDisplayName(key, title);
      legendSelected[displayName] = true;
      const arr = data.series[key] || Array(chartLabels.length).fill(null);
      return { name: displayName, key: key, type:'line', data: arr, smooth: true, showSymbol:false, lineStyle:{width:2}, emphasis:{focus:'series'}, connectNulls:false };
    });

    chart.setOption({
      tooltip:{ trigger:'axis', confine:true, valueFormatter: (value) => fmt(value) + (unit ? ` ${unit}`: '') },
      color: palette, legend:{ show:false, selected: legendSelected },
      grid:{ left:55,right:25,top:40,bottom:36,containLabel:false },
      xAxis:{ type:'category', data: chartLabels, axisLabel:{ hideOverlap: true, formatter: (value) => {
          const date = new Date(value);
          return useDailyTimeFormat ? echarts.format.formatTime('MM-dd', date) : echarts.format.formatTime('HH:mm', date);
        }
      }},
      yAxis:{ type:'value', axisLine:{show:false}, splitLine:{lineStyle:{color:'#e5e7eb'}}, axisLabel: { formatter: (v) => fmt(v) } },
      series
    });

    const tbody = card.querySelector('tbody');
    const thead = card.querySelector('thead');
    const btns = card.querySelectorAll('.actions .btn');
    let rows = seriesKeys.map((key, i) => {
      const arr = data.series[key] || [];
      const st = stats(arr);
      return { key: key, displayName: getDisplayName(key, title), idx:i, color: palette[i % palette.length], min: st.min, max: st.max, avg: st.avg, p95: st.p95, on: true };
    });
    let sortState = {k:'name', asc:true};

    function renderRows(){
      const k = sortState.k;
      rows.sort((a,b) => {
        if (k==='name') return sortState.asc ? a.displayName.localeCompare(b.displayName) : b.displayName.localeCompare(a.displayName);
        const av = a[k]; const bv = b[k];
        if (av==null && bv==null) return 0;
        if (av==null) return 1;
        if (bv==null) return -1;
        return sortState.asc ? (av-bv) : (bv-av);
      });
      tbody.innerHTML='';
      for (const r of rows){
        const tr = document.createElement('tr');
        tr.className = r.on ? '' : 'off';
        tr.dataset.key = r.key;
        tr.innerHTML = `<td class="namecell"><span class="dot" style="background:${r.color}"></span><span>${r.displayName}</span></td><td>${fmt(r.min)} ${unit||''}</td><td>${fmt(r.avg)} ${unit||''}</td><td>${fmt(r.max)} ${unit||''}</td><td>${fmt(r.p95)} ${unit||''}</td>`;
        tr.addEventListener('click', (ev) => {
          const isolate = ev.metaKey || ev.ctrlKey;
          if (isolate){
            for (const rr of rows){ rr.on = (rr.key === r.key); legendSelected[rr.displayName] = rr.on; }
          } else { r.on = !r.on; legendSelected[r.displayName] = r.on; }
          chart.setOption({legend:{selected:legendSelected}});
          renderRows();
        });
        tbody.appendChild(tr);
      }
    }
    renderRows();

    thead.querySelectorAll('th.sortable').forEach(th=>{
      th.addEventListener('click', ()=>{
        const k = th.dataset.k;
        if (sortState.k===k){ sortState.asc = !sortState.asc; } else { sortState.k=k; sortState.asc = (k==='name'); }
        thead.querySelectorAll('th').forEach(x=>x.classList.remove('asc'));
        if (sortState.asc) th.classList.add('asc');
        renderRows();
      });
    });
    btns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const act = btn.dataset.act;
        if (act==='all'){ rows.forEach(r=>{ r.on=true; legendSelected[r.displayName]=true; }); } 
        else if (act==='none'){ rows.forEach(r=>{ r.on=false; legendSelected[r.displayName]=false; }); }
        else if (act==='inverse'){ rows.forEach(r=>{ r.on=!r.on; legendSelected[r.displayName]=r.on; }); }
        chart.setOption({legend:{selected:legendSelected}});
        renderRows();
      });
    });
    window.addEventListener('resize', () => {
        document.querySelectorAll('.chart, .repl-chart').forEach(c => echarts.getInstanceByDom(c)?.resize());
        document.querySelectorAll('.sec-title:not(.collapsed) + .grid, .summary-container').forEach(grid => {
            if (grid.style.maxHeight !== '0px') {
                grid.style.maxHeight = grid.scrollHeight + 'px';
            }
        });
    });
    return card;
  }
  
  const gMongo = buildSection('Mongo');
  buildCard(gMongo, 'Connections', ['connections_created_per_sec','connections_current','connections_available'], '');
  buildCard(gMongo, 'Opcounters (per sec)', ['opcounters_query_per_sec','opcounters_insert_per_sec','opcounters_update_per_sec','opcounters_delete_per_sec','opcounters_command_per_sec'], '');
  buildCard(gMongo, 'Documents (per sec)', ['docs_returned_per_sec','docs_inserted_per_sec','docs_updated_per_sec','docs_deleted_per_sec'], '');
  buildCard(gMongo, 'Op Latency (avg µs)', ['latency_reads_avg_ms','latency_writes_avg_ms','latency_commands_avg_ms'], 'µs');
  buildCard(gMongo, 'Query Executor (per sec)', ['query_scanned_keys_per_sec','query_scanned_objects_per_sec','query_collection_scans_total_per_sec','query_collection_scans_nontailable_per_sec'], '');
  buildCard(gMongo, 'TTL (per sec)', ['ttl_passes_per_sec','ttl_deletedDocuments_per_sec'], '');

  const gWT = buildSection('WiredTiger');
  buildCard(gWT, 'Cache (MB)', ['wt_cache_bytes_in_cache_mb','wt_cache_dirty_bytes_mb','wt_cache_max_bytes_mb'], 'MB');
  buildCard(gWT, 'IO (MB/s)', ['wt_read_mb_per_sec','wt_write_mb_per_sec'], 'MB/s');
  buildCard(gWT, 'Cache Pages Evicted (per sec)', ['wt_pages_evicted_modified_per_sec', 'wt_pages_evicted_unmodified_per_sec'], 'pages/s');
  buildCard(gWT, 'Tickets', ['wt_tickets_avail_read','wt_tickets_avail_write'], '');

  const gOS = buildSection('OS');
  buildCard(gOS, 'CPU (%)', ['cpu_user_percent','cpu_system_percent','cpu_iowait_percent','cpu_softirq_percent','cpu_nice_percent','cpu_idle_percent'], '%');
  buildCard(gOS, 'Memory (MB)', ['sys_mem_available_mb','sys_mem_total_mb'], 'MB');
  buildCard(gOS, 'Network (MB/s)', ['network_bytes_in_per_sec','network_bytes_out_per_sec'], 'MB/s');

  const gDisk = buildSection('OS / Disks');
  const allKeys = Object.keys(data.series);
  const iopsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_iops_') || k.includes('_write_iops_')));
  const mbpsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_mbps_') || k.includes('_write_mbps_')));
  const latKeys     = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_latency_ms_') || k.includes('_write_latency_ms_')));
  const utilKeys    = allKeys.filter(k => k.startsWith('disk_') && k.includes('_utilization_percent_'));
  const queueKeys   = allKeys.filter(k => k.startsWith('disk_') && k.includes('_queue_depth_avg_'));
  buildCard(gDisk, 'Disk IOPS (per device)', iopsKeys, 'iops');
  buildCard(gDisk, 'Disk Throughput (MB/s per device)', mbpsKeys, 'MB/s');
  buildCard(gDisk, 'Disk Latency (ms per device)', latKeys, 'ms');
  buildCard(gDisk, 'Disk Utilization (% per device)', utilKeys, '%');
  buildCard(gDisk, 'Disk Queue Depth (avg per device)', queueKeys, '');
})();
</script>
</body>
</html>