<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>FTDC Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    /* Style variables for consistent theming.
      We define colors for background, text,
      cards, borders, and other elements here.
    */
    :root {
      --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --grid:#e5e7eb;
      --border:#e2e8f0; --subtle:#f1f5f9; --chip:#334155; --chipbg:#e2e8f0; --red: #ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial}
    header{padding:16px 24px;border-bottom:1px solid var(--border);display:flex;gap:16px;align-items:center;background:var(--card)}
    h1{font-size:16px;margin:0}
    .wrap{width:100%;margin:0 auto;padding:24px;display:grid;grid-template-columns:1fr;gap:18px}
    
    /* Styles for the main collapsible sections
      that group the chart cards together.
    */
    .section{margin-top:8px}
    .sec-title{font-size:18px;font-weight:700;margin:12px 0 16px 4px;color:#0f172a;cursor:pointer;position:relative;padding-left:20px;user-select:none}
    .sec-title::before { content: '▼'; position: absolute; left: 0; top: 50%; transform: translateY(-50%); font-size: 12px; transition: transform 0.2s; }
    .sec-title.collapsed::before { transform: translateY(-50%) rotate(-90deg); }
    
    /* Grid layout for the chart cards.
      It defaults to one column and becomes
      two columns on wider screens.
    */
    .grid{display:grid;grid-template-columns:1fr;gap:24px; overflow:hidden; transition: max-height 0.3s ease-in-out;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05);}
    .pane{padding:16px 16px 8px}
    .title{font-size:16px; color:#1e293b; font-weight:600; margin:0 0 12px 2px}
    .chart{width:100%;height:340px}
    
    /*
      Table styles used inside each chart card
      to display detailed metric statistics.
    */
    .tablewrap{border-top:1px solid var(--border);background:var(--subtle); color: var(--muted); font-size: 13px;}
    .actions{display:flex;gap:8px;align-items:center;padding:10px 12px}
    .btn{border:1px solid var(--border);background:#fff;border-radius:8px;padding:6px 10px;cursor:pointer; font-size:12px;}
    .btn:hover{background:#f1f5f9}
    table{width:100%;border-collapse:collapse}
    thead th{font-weight:600;color:#111827;background:var(--subtle);border-top:1px solid var(--border);border-bottom:1px solid var(--border); font-size:12px;}
    thead th, tbody td{padding:8px 12px;border-bottom:1px solid var(--border);text-align:right;white-space:nowrap}
    thead th:first-child, tbody td:first-child{text-align:left}
    tbody tr{background:#fff;cursor:pointer}
    tbody tr.off{color:#94a3b8}
    tbody tr:hover{background:var(--subtle)}
    .namecell{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;border:1px solid rgba(0,0,0,.15)}
    .chip{font-size:12px;color:var(--chip);background:var(--chipbg);padding:2px 8px;border-radius:999px}
    .muted{color:var(--muted)}
    .sortable{cursor:pointer}
    .sortable::after{content:"";margin-left:6px;border:4px solid transparent;border-top-color:#94a3b8;display:inline-block;transform:translateY(2px)}
    .asc.sortable::after{border-top-color:transparent;border-bottom-color:#334155;transform:translateY(-2px)}
    
    /*
      Styles for the top summary panel.
    */
    .summary-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: stretch; overflow: hidden; transition: max-height 0.3s ease-in-out; }
    .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px; }
    .summary-section h3 { font-size: 14px; margin: 0 0 8px; color: var(--muted); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
    .summary-section ul { margin: 0; padding: 0; list-style: none; }
    .summary-section li { display: flex; justify-content: space-between; padding: 4px 0; flex-wrap: wrap; }
    .summary-section li span:first-child { font-weight: 600; color: var(--fg); margin-right: 8px; }
    .summary-section li span:last-child { color: var(--muted); text-align: right; }
    
    /*
      Styles for the collapsible config viewer.
    */
    details.config-details { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
    summary.config-summary { cursor: pointer; padding: 8px 12px; font-weight: 600; background: var(--subtle); list-style: none; }
    summary.config-summary::-webkit-details-marker { display: none; }
    .config-view { margin:0; background: #0d1117; color: #c9d1d9; font-family: monospace; font-size: 13px; padding: 16px; overflow: auto; line-height: 1.6; max-height: 250px; }
    .config-change-dot { color: var(--red); margin-left: 8px; font-size: 16px; line-height: 1; display: inline-block; vertical-align: middle; }

    /* Media queries for responsive layout adjustments. */
    @media (min-width: 1200px) { .grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 1024px) { .summary-container { grid-template-columns: 1fr; } }
    @media (max-width: 768px) { .summary-grid { grid-template-columns: 1fr; } }
    @media (max-width:1000px){ .chart{height:300px} }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
<header>
  <h1>FTDC Dashboard</h1>
</header>

<div class="wrap" id="wrap"></div>

<script>
(async function () {
  const res = await fetch('/api/data');
  const data = await res.json();

  const W = document.getElementById('wrap');
  const L = data.labels;

  /* ========================================================
    SUMMARY AND CONFIGURATION VIEWER
    ========================================================
  */
  const getConfigVal = (path, fallback = 'N/A') => {
    try {
      const value = path.split('.').reduce((o, k) => o[k], data.config);
      if (typeof value === 'object' && value !== null) {
        if ('$numberInt' in value) return value['$numberInt'];
        if ('$numberLong' in value) return value['$numberLong'];
      }
      return value ?? fallback;
    } catch (e) {
      return fallback;
    }
  };

  function buildSummaryViewer(config, configChanged) {
    if (!config) return;

    const section = document.createElement('div');
    section.className = 'section';
    
    const title = document.createElement('div');
    title.className = 'sec-title';
    title.textContent = 'Host & Configuration Summary';
    
    const content = document.createElement('div');
    content.className = 'summary-container'; 

    const summaryWrapper = document.createElement('div');
    summaryWrapper.className = 'summary-grid';
    summaryWrapper.innerHTML = `
      <div class="summary-section">
        <h3>Version & Build</h3>
        <ul>
          <li><span>Hostname:</span> <span>${getConfigVal('hostInfo.system.hostname')}</span></li>
          <li><span>Mongo Version:</span> <span>${getConfigVal('buildInfo.version')} (${(getConfigVal('buildInfo.modules.0', 'community'))})</span></li>
          <li><span>OS:</span> <span>${getConfigVal('hostInfo.os.name')}</span></li>
          <li><span>Git Version:</span> <span>${getConfigVal('buildInfo.gitVersion')}</span></li>
        </ul>
      </div>
      <div class="summary-section">
        <h3>Network & Replication</h3>
        <ul>
          <li><span>IP Addresses:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.bindIp')}</span></li>
          <li><span>Port:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.port')}</span></li>
          <li><span>Replica Set:</span> <span>${getConfigVal('getCmdLineOpts.parsed.replication.replSetName', 'Not in a replicaset')}</span></li>
          <li><span>Security:</span> <span>${getConfigVal('getCmdLineOpts.parsed.security.clusterAuthMode', 'N/A')}</span></li>
          <li><span>TLS Mode:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.tls.mode', 'disabled')}</span></li>
        </ul>
      </div>
      <div class="summary-section">
        <h3>Storage & Logging</h3>
        <ul>
          <li><span>Data Path (dbPath):</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.dbPath')}</span></li>
          <li><span>Log Path:</span> <span>${getConfigVal('getCmdLineOpts.parsed.systemLog.path')}</span></li>
          <li><span>Journaling:</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.journal.enabled', 'false')}</span></li>
        </ul>
      </div>
      <div class="summary-section">
        <h3>Server & Limits</h3>
        <ul>
          <li><span>CPU:</span> <span>${getConfigVal('hostInfo.system.numCores')} Cores</span></li>
          <li><span>CPU Arch:</span> <span>${getConfigVal('hostInfo.system.cpuArch')}</span></li>
          <li><span>RAM:</span> <span>${getConfigVal('hostInfo.system.memSizeMB')} MB</span></li>
          <li><span>Open Files Limit:</span> <span>${getConfigVal('ulimits.fileDescriptors.soft')}</span></li>
        </ul>
      </div>
    `;

    const configWrapper = document.createElement('div');
    const activeConfig = getConfigVal('getCmdLineOpts.parsed', {});
    
    configWrapper.innerHTML = `
      <details class="config-details">
        <summary class="config-summary">
          Active Configuration (parsed)
          ${configChanged ? '<span class="config-change-dot" title="Configuration changed during this period">●</span>' : ''}
        </summary>
        <pre class="config-view">${JSON.stringify(activeConfig, null, 2)}</pre>
      </details>
    `;

    content.appendChild(summaryWrapper);
    content.appendChild(configWrapper);
    section.appendChild(title);
    section.appendChild(content);
    W.insertBefore(section, W.firstChild);

    // This is the key fix. We set the initial maxHeight
    // AFTER the content is fully built and added to the DOM.
    content.style.maxHeight = content.scrollHeight + 'px';

    title.addEventListener('click', () => {
      title.classList.toggle('collapsed');
      const isCollapsed = title.classList.contains('collapsed');
      content.style.maxHeight = isCollapsed ? '0px' : (content.scrollHeight + 'px');
    });
  }

  buildSummaryViewer(data.config, data.config_changed);


  /* ========================================================
    CHART AND SECTION BUILDERS
    ========================================================
  */

  function stats(arr){
    const vals = (arr||[]).filter(v => typeof v === 'number' && !Number.isNaN(v));
    if (!vals.length) return {min:null,max:null,avg:null,p95:null};
    vals.sort((a, b) => a - b);
    const p95Index = Math.floor(vals.length * 0.95);
    const p95 = vals[p95Index];
    let min=vals[0], max=vals[vals.length - 1], sum=0;
    for (const v of vals){ sum+=v; }
    return {min, max, avg: sum/vals.length, p95};
  }

  function fmt(v){
    if (v == null || typeof v !== 'number' || Number.isNaN(v)) return '—';
    return v.toFixed(2);
  }

  function buildSection(title){ 
    const s = document.createElement('div'); 
    s.className='section';
    const secTitle = document.createElement('div');
    secTitle.className = 'sec-title';
    secTitle.textContent = title;
    const grid = document.createElement('div');
    grid.className = 'grid';
    s.appendChild(secTitle);
    s.appendChild(grid);
    W.appendChild(s);

    secTitle.addEventListener('click', () => {
      secTitle.classList.toggle('collapsed');
      const isCollapsed = secTitle.classList.contains('collapsed');
      grid.style.maxHeight = isCollapsed ? '0px' : (grid.scrollHeight + 'px');
    });
    return grid; 
  }

  function getDisplayName(key, title) {
      if (title.toLowerCase().includes('disk')) {
        const parts = key.split('_');
        const device = parts[parts.length - 1];
        if (key.includes('_read_')) return `${device} (read)`;
        if (key.includes('_write_')) return `${device} (write)`;
        return device;
      }
      if (key.startsWith('wt_pages_evicted_')) {
        return key.includes('_modified_') ? 'modified' : 'unmodified';
      }
      return key;
  }

  function buildCard(grid, title, seriesKeys, unit){
    if (!seriesKeys || !seriesKeys.some(k => data.series[k])) return;
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<div class="pane"><div class="title">${title}</div><div class="chart"></div></div><div class="tablewrap"><div class="actions"><span class="chip">series</span><button class="btn" data-act="all">All</button><button class="btn" data-act="none">None</button><button class="btn" data-act="inverse">Inverse</button></div><table class="tbl"><thead><tr><th class="sortable asc" data-k="name">name</th><th class="sortable" data-k="min">min</th><th class="sortable" data-k="avg">avg</th><th class="sortable" data-k="max">max</th><th class="sortable" data-k="p95">p95</th></tr></thead><tbody></tbody></table></div>`;
    grid.appendChild(card);

    const chart = echarts.init(card.querySelector('.chart'), 'light', {renderer:'canvas'});
    const palette = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#0ea5e9','#f97316','#22c55e','#e11d48','#10b981','#a855f7','#84cc16'];
    const legendSelected = {};
    const series = seriesKeys.map((key, i) => {
      const displayName = getDisplayName(key, title);
      legendSelected[displayName] = true;
      const arr = data.series[key] || Array(L.length).fill(null);
      return { name: displayName, key: key, type:'line', data: arr, smooth: true, showSymbol:false, lineStyle:{width:2}, emphasis:{focus:'series'}, connectNulls:false };
    });

    chart.setOption({
      tooltip:{ trigger:'axis', confine:true, valueFormatter: (value) => fmt(value) + (unit ? ` ${unit}`: '') },
      color: palette, legend:{ show:false, selected: legendSelected },
      grid:{ left:55,right:25,top:40,bottom:36,containLabel:false },
      xAxis:{ type:'category', data:L, axisLabel:{show:false}, axisTick:{show:false}, axisLine:{lineStyle:{color:'#cbd5e1'}} },
      yAxis:{ type:'value', axisLine:{show:false}, splitLine:{lineStyle:{color:'#e5e7eb'}}, axisLabel: { formatter: (v) => fmt(v) } },
      series
    });

    const tbody = card.querySelector('tbody');
    const thead = card.querySelector('thead');
    const btns = card.querySelectorAll('.actions .btn');
    let rows = seriesKeys.map((key, i) => {
      const arr = data.series[key] || [];
      const st = stats(arr);
      return { key: key, displayName: getDisplayName(key, title), idx:i, color: palette[i % palette.length], min: st.min, max: st.max, avg: st.avg, p95: st.p95, on: true };
    });
    let sortState = {k:'name', asc:true};

    function renderRows(){
      const k = sortState.k;
      rows.sort((a,b) => {
        if (k==='name') return sortState.asc ? a.displayName.localeCompare(b.displayName) : b.displayName.localeCompare(a.displayName);
        const av = a[k]; const bv = b[k];
        if (av==null && bv==null) return 0;
        if (av==null) return 1;
        if (bv==null) return -1;
        return sortState.asc ? (av-bv) : (bv-av);
      });
      tbody.innerHTML='';
      for (const r of rows){
        const tr = document.createElement('tr');
        tr.className = r.on ? '' : 'off';
        tr.dataset.key = r.key;
        tr.innerHTML = `<td class="namecell"><span class="dot" style="background:${r.color}"></span><span>${r.displayName}</span></td><td>${fmt(r.min)} ${unit||''}</td><td>${fmt(r.avg)} ${unit||''}</td><td>${fmt(r.max)} ${unit||''}</td><td>${fmt(r.p95)} ${unit||''}</td>`;
        tr.addEventListener('click', (ev) => {
          const isolate = ev.metaKey || ev.ctrlKey;
          if (isolate){
            for (const rr of rows){ rr.on = (rr.key === r.key); legendSelected[rr.displayName] = rr.on; }
          } else { r.on = !r.on; legendSelected[r.displayName] = r.on; }
          chart.setOption({legend:{selected:legendSelected}});
          renderRows();
        });
        tbody.appendChild(tr);
      }
    }
    renderRows();

    thead.querySelectorAll('th.sortable').forEach(th=>{
      th.addEventListener('click', ()=>{
        const k = th.dataset.k;
        if (sortState.k===k){ sortState.asc = !sortState.asc; } else { sortState.k=k; sortState.asc = (k==='name'); }
        thead.querySelectorAll('th').forEach(x=>x.classList.remove('asc'));
        if (sortState.asc) th.classList.add('asc');
        renderRows();
      });
    });
    btns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const act = btn.dataset.act;
        if (act==='all'){ rows.forEach(r=>{ r.on=true; legendSelected[r.displayName]=true; }); } 
        else if (act==='none'){ rows.forEach(r=>{ r.on=false; legendSelected[r.displayName]=false; }); }
        else if (act==='inverse'){ rows.forEach(r=>{ r.on=!r.on; legendSelected[r.displayName]=r.on; }); }
        chart.setOption({legend:{selected:legendSelected}});
        renderRows();
      });
    });
    window.addEventListener('resize', () => {
        chart.resize();
        document.querySelectorAll('.sec-title:not(.collapsed) + .grid, .summary-container').forEach(grid => {
            if (grid.style.maxHeight !== '0px') {
                grid.style.maxHeight = grid.scrollHeight + 'px';
            }
        });
    });
    return card;
  }

  /* ========================================================
    DEFINE ALL DASHBOARD SECTIONS AND CARDS
    ========================================================
  */
  
  const gMongo = buildSection('Mongo');
  buildCard(gMongo, 'Connections', ['connections_created_per_sec','connections_current','connections_available'], '');
  buildCard(gMongo, 'Opcounters (per sec)', ['opcounters_query_per_sec','opcounters_insert_per_sec','opcounters_update_per_sec','opcounters_delete_per_sec','opcounters_command_per_sec'], '');
  buildCard(gMongo, 'Documents (per sec)', ['docs_returned_per_sec','docs_inserted_per_sec','docs_updated_per_sec','docs_deleted_per_sec'], '');
  buildCard(gMongo, 'Op Latency (avg µs)', ['latency_reads_avg_ms','latency_writes_avg_ms','latency_commands_avg_ms'], 'µs');
  buildCard(gMongo, 'Query Executor (per sec)', ['query_scanned_keys_per_sec','query_scanned_objects_per_sec','query_collection_scans_total_per_sec','query_collection_scans_nontailable_per_sec'], '');
  buildCard(gMongo, 'TTL (per sec)', ['ttl_passes_per_sec','ttl_deletedDocuments_per_sec'], '');

  const gWT = buildSection('WiredTiger');
  buildCard(gWT, 'Cache (MB)', ['wt_cache_bytes_in_cache_mb','wt_cache_dirty_bytes_mb','wt_cache_max_bytes_mb'], 'MB');
  buildCard(gWT, 'IO (MB/s)', ['wt_read_mb_per_sec','wt_write_mb_per_sec'], 'MB/s');
  buildCard(gWT, 'Cache Pages Evicted (per sec)', ['wt_pages_evicted_modified_per_sec', 'wt_pages_evicted_unmodified_per_sec'], 'pages/s');
  buildCard(gWT, 'Tickets', ['wt_tickets_avail_read','wt_tickets_avail_write'], '');

  const gOS = buildSection('OS');
  buildCard(gOS, 'CPU (%)', ['cpu_user_percent','cpu_system_percent','cpu_iowait_percent','cpu_softirq_percent','cpu_nice_percent','cpu_idle_percent'], '%');
  buildCard(gOS, 'Memory (MB)', ['sys_mem_available_mb','sys_mem_total_mb'], 'MB');
  buildCard(gOS, 'Network (MB/s)', ['network_bytes_in_per_sec','network_bytes_out_per_sec'], 'MB/s');

  const gDisk = buildSection('OS / Disks');
  const allKeys = Object.keys(data.series);
  const iopsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_iops_') || k.includes('_write_iops_')));
  const mbpsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_mbps_') || k.includes('_write_mbps_')));
  const latKeys     = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_latency_ms_') || k.includes('_write_latency_ms_')));
  const utilKeys    = allKeys.filter(k => k.startsWith('disk_') && k.includes('_utilization_percent_'));
  const queueKeys   = allKeys.filter(k => k.startsWith('disk_') && k.includes('_queue_depth_avg_'));
  buildCard(gDisk, 'Disk IOPS (per device)', iopsKeys, 'iops');
  buildCard(gDisk, 'Disk Throughput (MB/s per device)', mbpsKeys, 'MB/s');
  buildCard(gDisk, 'Disk Latency (ms per device)', latKeys, 'ms');
  buildCard(gDisk, 'Disk Utilization (% per device)', utilKeys, '%');
  buildCard(gDisk, 'Disk Queue Depth (avg per device)', queueKeys, '');
})();
</script>
</body>
</html>