<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>FTDC Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root {
      --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --grid:#e5e7eb;
      --border:#e2e8f0; --subtle:#f1f5f9; --chip:#334155; --chipbg:#e2e8f0; --red: #ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial}
    header{padding:16px 24px;border-bottom:1px solid var(--border);display:flex;gap:16px;align-items:center;background:var(--card)}
    h1{font-size:16px;margin:0}
    /* Timezone CSS Eklentisi */
    .timezone-selector {margin-left: auto; display: flex; align-items: center; gap: 8px;}
    .timezone-selector label {font-size: 12px; font-weight: 500; color: var(--muted);}
    .timezone-selector select {border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 12px; background: white;}
    /* Ortak CSS devamı */
    .wrap{width:100%;margin:0 auto;padding:24px;display:grid;grid-template-columns:1fr;gap:18px}
    .section{margin-top:8px}
    .sec-title{font-size:18px;font-weight:700;margin:12px 0 16px 4px;color:#0f172a;cursor:pointer;position:relative;padding-left:20px;user-select:none}
    .sec-title::before { content: '▼'; position: absolute; left: 0; top: 50%; transform: translateY(-50%); font-size: 12px; transition: transform 0.2s; }
    .sec-title.collapsed::before { transform: translateY(-50%) rotate(-90deg); }
    .grid{display:grid;grid-template-columns:1fr;gap:24px; overflow:hidden; transition: max-height 0.3s ease-in-out;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05);}
    .pane{padding:16px 16px 8px}
    .title{font-size:16px; color:#1e293b; font-weight:600; margin:0 0 12px 2px}
    .chart{width:100%;height:340px}
    .tablewrap{border-top:1px solid var(--border);background:var(--subtle); color: var(--muted); font-size: 13px;}
    .actions{display:flex;gap:8px;align-items:center;padding:10px 12px}
    .btn{border:1px solid var(--border);background:#fff;border-radius:8px;padding:6px 10px;cursor:pointer; font-size:12px;}
    .btn:hover{background:#f1f5f9}
    table{width:100%;border-collapse:collapse}
    thead th{font-weight:600;color:#111827;background:var(--subtle);border-top:1px solid var(--border);border-bottom:1px solid var(--border); font-size:12px;}
    thead th, tbody td{padding:8px 12px;border-bottom:1px solid var(--border);text-align:right;white-space:nowrap}
    thead th:first-child, tbody td:first-child{text-align:left}
    tbody tr{background:#fff;cursor:pointer}
    tbody tr.off{color:#94a3b8}
    tbody tr:hover{background:var(--subtle)}
    .namecell{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;border:1px solid rgba(0,0,0,.15)}
    .chip{font-size:12px;color:var(--chip);background:var(--chipbg);padding:2px 8px;border-radius:999px}
    .muted{color:var(--muted)}
    .sortable{cursor:pointer}
    .sortable::after{content:"";margin-left:6px;border:4px solid transparent;border-top-color:#94a3b8;display:inline-block;transform:translateY(2px)}
    .asc.sortable::after{border-top-color:transparent;border-bottom-color:#334155;transform:translateY(-2px)}
    .summary-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: stretch; overflow: hidden; transition: max-height 0.3s ease-in-out; }
    .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px; }
    .summary-section h3 { font-size: 14px; margin: 0 0 8px; color: var(--muted); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
    .summary-section ul { margin: 0; padding: 0; list-style: none; }
    .summary-section li { display: flex; justify-content: space-between; padding: 4px 0; flex-wrap: wrap; }
    .summary-section li span:first-child { font-weight: 600; color: var(--fg); margin-right: 8px; }
    .summary-section li span:last-child { color: var(--muted); text-align: right; }
    details.config-details { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
    summary.config-summary { cursor: pointer; padding: 8px 12px; font-weight: 600; background: var(--subtle); list-style: none; }
    summary.config-summary::-webkit-details-marker { display: none; }
    .config-view { margin:0; background: #0d1117; color: #c9d1d9; font-family: monospace; font-size: 13px; padding: 16px; overflow: auto; line-height: 1.6; max-height: 250px; }
    .config-change-dot { color: var(--red); margin-left: 8px; font-size: 16px; line-height: 1; display: inline-block; vertical-align: middle; }
    .repl-chart-container { background:var(--card); border:1px solid var(--border); border-radius:12px; overflow:hidden; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05); padding: 16px; }
    .repl-chart { width: 100%; }
    .custom-metrics-card { grid-column: 1 / -1; }
    .card.wide-card { grid-column: 1 / -1; }
    .custom-metrics-chart { width: 100%; min-height: 320px; }
    .metrics-selector { position: relative; margin-bottom: 12px; }
    .metrics-selector summary, .metrics-selector .dropdown-trigger { cursor: pointer; font-weight: 600; font-size: 14px; color: var(--fg); padding: 8px 12px; background: var(--subtle); border: 1px solid var(--border); border-radius: 8px; display: inline-block; user-select: none; list-style: none; }
    .metrics-selector summary::-webkit-details-marker { display: none; }
    .metrics-dropdown { display: none; margin-top: 8px; padding: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; max-height: 280px; overflow-y: auto; }
    .metrics-selector details[open] .metrics-dropdown { display: block; }
    .metrics-dropdown label { display: block; padding: 4px 0; cursor: pointer; font-size: 13px; }
    .metrics-dropdown label:hover { background: var(--subtle); }
    .metrics-dropdown input { margin-right: 8px; }
    @media (min-width: 1200px) { .grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 1024px) { .summary-container { grid-template-columns: 1fr; } }
    @media (max-width: 768px) { .summary-grid { grid-template-columns: 1fr; } }
    @media (max-width:1000px){ .chart{height:300px} }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
<header>
  <h1>FTDC Dashboard</h1>
  <div class="timezone-selector">
    <label for="timezone-select">Timezone:</label>
    <select id="timezone-select">
      <option value="browser">Browser Time (Local)</option>
      <option value="UTC" selected>UTC</option>
      <option value="America/New_York">EST/EDT (-05:00/-04:00)</option>
      <option value="America/Chicago">CST/CDT (-06:00/-05:00)</option>
      <option value="America/Denver">MST/MDT (-07:00/-06:00)</option>
      <option value="America/Los_Angeles">PST/PDT (-08:00/-07:00)</option>
      <option value="Europe/London">GMT/BST (+00:00/+01:00)</option>
      <option value="Europe/Paris">CET/CEST (+01:00/+02:00)</option>
      <option value="Europe/Istanbul">TRT (+03:00)</option>
      <option value="Asia/Dubai">GST (+04:00)</option>
      <option value="Asia/Kolkata">IST (+05:30)</option>
      <option value="Asia/Shanghai">CST (+08:00)</option>
      <option value="Asia/Tokyo">JST (+09:00)</option>
      <option value="Australia/Sydney">AEST/AEDT (+10:00/+11:00)</option>
    </select>
  </div>
</header>

<div class="wrap" id="wrap"></div>

<script>
// --- BAŞLANGIÇ: Timezone Yönetimi ve Fonksiyonları ---
let currentTimezone = 'UTC';
let timezoneOffset = 0; 
let globalData = {}; // Data'yı global tutmak için

function updateTimezoneOffset() {
  if (currentTimezone === 'browser') {
    // Browser time'da ofset gerekmez, JS zaten yerel saatte çalışır
    timezoneOffset = 0; 
  } else if (currentTimezone === 'UTC') {
    timezoneOffset = 0;
  } else {
    try {
        // Belirtilen timezone'a göre ofseti hesapla
        const now = new Date();
        const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000); 
        const tzTime = new Date(now.toLocaleString('en-US', { timeZone: currentTimezone })).getTime();
        timezoneOffset = tzTime - utcTime; 
    } catch (e) {
      console.warn('Error calculating timezone offset, falling back to UTC', e);
      timezoneOffset = 0;
      currentTimezone = 'UTC';
      document.getElementById('timezone-select').value = 'UTC';
    }
  }
}

/**
 * UTC timestamp'i seçilen zaman dilimine göre formatlar.
 * @param {number} timestamp - UTC zamanı (milliseconds).
 * @param {string} type - 'short' (akıllı x-ekseni) veya 'full' (tooltip için).
 * @param {number} [durationHours=0] - Toplam gösterilen zaman aralığı (saat cinsinden).
 * @returns {string} Formatlanmış zaman string'i.
 */
function formatTimeForTimezone(timestamp, type, durationHours = 0) {
  let date;

  if (currentTimezone === 'browser') {
    // Browser Timezone kullanılıyorsa, tarih objesini olduğu gibi kullan
    date = new Date(timestamp);
  } else {
    // Diğer Timezone'lar için, UTC zamanına ofseti ekle
    date = new Date(timestamp + timezoneOffset);
  }

  const tzOpt = currentTimezone === 'browser' ? undefined : { timeZone: 'UTC' }; // date.toLocaleString'e 'UTC' dersek, offset'li tarih yerel saatmiş gibi davranır
  
  if (type === 'full') {
    // Her zaman tam format: "Mar 12, 2024 14:30:45 UTC"
    const options = {
      year: 'numeric', month: 'short', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit', 
      hour12: false, 
      ...tzOpt
    };
    let timeStr = date.toLocaleString('en-US', options);
    // TimeZone adını sonuna ekle (UTC, EST vb.)
    if (currentTimezone === 'browser') {
        return timeStr;
    } else if (currentTimezone === 'UTC') {
        return `${timeStr} UTC`;
    } else {
        return `${timeStr} ${currentTimezone.split('/').pop().replace('_', ' ')}`;
    }


  } else if (type === 'short') {
    // X-ekseni için akıllı formatlama
    if (durationHours > 48) { 
      // 48 saatten uzun: "Mar 12" formatında
      return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: '2-digit',
        ...tzOpt
      });
    } else {
      // 48 saatten kısa: "14:30" formatında
      return date.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false,
        ...tzOpt
      });
    }
  }
}


function updateAllCharts() {
  const L = globalData.labels;
  const totalDurationHours = (L && L.length > 1) 
      ? (new Date(L[L.length - 1]).getTime() - new Date(L[0]).getTime()) / (1000 * 60 * 60) 
      : 0;

  document.querySelectorAll('.chart, .repl-chart').forEach(chartEl => {
    const chart = echarts.getInstanceByDom(chartEl);
    if (chart) {
      const option = chart.getOption();
      
      // 1. X-Ekseni Formatını Güncelle
      if (option.xAxis && option.xAxis[0]) {
        option.xAxis[0].axisLabel = {
          ...option.xAxis[0].axisLabel,
          formatter: function(value) {
            return formatTimeForTimezone(value, 'short', totalDurationHours); 
          }
        };
      }
      
      // 2. Standart Chart Tooltip Formatını Güncelle (Axis Pointer)
      if (option.tooltip && option.tooltip.trigger === 'axis' && option.xAxis) {
         // Tooltip'i tamamen yeniden yazmak yerine, timestamp'i doğru şekilde formatlayalım.
         // ECharts'ın default tooltip formatlayıcısını kullanmak yerine, tam kontrol için formatter'ı ayarla
         option.tooltip.formatter = function(params) {
              if (params.length === 0) return '';
              let output = formatTimeForTimezone(params[0].value[0], 'full'); // X eksenindeki zamanı formatla
              params.forEach(param => {
                  const unit = chartEl.closest('.card').querySelector('.tbl')?.querySelector('tbody')?.querySelector(`tr[data-key="${param.seriesName}"]`)?.children[1]?.textContent.split(' ').pop() || '';
                  output += `<br/><span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: ${fmt(param.value[1])} ${unit}`;
              });
              return output;
          };
      }
      
      // 3. Timeline Chart Tooltip Formatını Güncelle (sadece repl-chart için)
      if (option.series && option.series[0] && option.series[0].type === 'custom') {
          const nodeNames = option.yAxis[0].data; 
          option.tooltip.formatter = function(params) {
              if (Array.isArray(params)) { return 'Error: Array in timeline tooltip'; }
              
              const state = params.value[3];
              const start = formatTimeForTimezone(params.value[1], 'full');
              const end = formatTimeForTimezone(params.value[2], 'full');
              
              return `${nodeNames[params.value[0]]}<br/><b>${state}</b><br/>${start} - ${end}`;
          };
      }


      chart.setOption(option, { notMerge: false });
    }
  });
}

// Timezone selector event listener
document.getElementById('timezone-select').addEventListener('change', function(e) {
  currentTimezone = e.target.value;
  updateTimezoneOffset();
  updateAllCharts();
});

updateTimezoneOffset();

(async function () {
  try {
    const res = await fetch('/api/data'); 
    globalData = await res.json(); // Data'yı global değişkene ata
  } catch (e) {
    console.error("Veri çekilemedi. Grafik çizimi boş veriyle devam ediyor.", e);
    // Hata durumunda boş, ancak geçerli bir data yapısıyla devam et.
    globalData = { labels: [], series: {}, config: {}, repl_timeline: [] };
  }

  const W = document.getElementById('wrap');
  const L = globalData.labels;

  const totalDurationHours = (L && L.length > 1) ? (new Date(L[L.length - 1]).getTime() - new Date(L[0]).getTime()) / (1000 * 60 * 60) : 0;
  // Eski kodunuzdaki useDailyTimeFormat kontrolü artık formatTimeForTimezone içinde yapılıyor.
  // const useDailyTimeFormat = totalDurationHours > 48; 

  function buildReplStatusChartContainer(timeline) {
    if (!timeline || timeline.length === 0) return null;
    
    const eventsByNode = timeline.reduce((acc, event) => {
        if (!acc[event.name]) acc[event.name] = [];
        acc[event.name].push(true);
        return acc;
    }, {});
    const nodeCount = Object.keys(eventsByNode).length;

    const container = document.createElement('div');
    container.className = 'section';
    const chartHeight = nodeCount * 40 + 60;
    container.innerHTML = `
        <div class="sec-title">Node States</div>
        <div class="repl-chart-container">
            <div class="repl-chart" style="height:${chartHeight}px"></div>
        </div>
    `;
    return container;
  }

  function initReplStatusChart(containerEl, timeline, labels) {
    if (!containerEl || !timeline || timeline.length === 0) return;

    const stateColors = {
        PRIMARY: '#6a994e', SECONDARY: '#f5b700', ARBITER: '#a2d2ff',
        RECOVERING: '#ef476f', STARTUP: '#8338ec', STARTUP2: '#8338ec',
        UNKNOWN: '#6c757d', DOWN: '#d62828', ROLLBACK: '#ff7b00',
    };
    const legendData = [];

    const eventsByNode = timeline.reduce((acc, event) => {
        if (!acc[event.name]) acc[event.name] = [];
        acc[event.name].push({ t: new Date(event.t), state: event.state });
        return acc;
    }, {});

    const nodeNames = Object.keys(eventsByNode).sort();
    const chartData = [];
    const stateSet = new Set();

    nodeNames.forEach((name, nodeIndex) => {
        const events = eventsByNode[name].sort((a, b) => a.t - b.t);
        if (events.length === 0) return;

        let segmentStartEvent = events[0];

        for (let i = 1; i < events.length; i++) {
            if (events[i].state !== segmentStartEvent.state) {
                const startTime = segmentStartEvent.t.getTime();
                const endTime = events[i].t.getTime();
                
                chartData.push({
                    name: segmentStartEvent.state,
                    value: [nodeIndex, startTime, endTime, segmentStartEvent.state]
                });
                stateSet.add(segmentStartEvent.state);
                segmentStartEvent = events[i];
            }
        }

        const lastSegmentStartTime = segmentStartEvent.t.getTime();
        const lastSegmentEndTime = new Date(labels[labels.length - 1]).getTime();
        chartData.push({
            name: segmentStartEvent.state,
            value: [nodeIndex, lastSegmentStartTime, lastSegmentEndTime, segmentStartEvent.state]
        });
        stateSet.add(segmentStartEvent.state);
    });

    for(const state of stateSet) {
        legendData.push({name: state, itemStyle: {color: stateColors[state] || '#ced4da'}});
    }
    
    const chartDom = containerEl.querySelector('.repl-chart');
    const myChart = echarts.init(chartDom);

    function renderItem(params, api) {
        const categoryIndex = api.value(0);
        const start = api.coord([api.value(1), categoryIndex]);
        const end = api.coord([api.value(2), categoryIndex]);
        const height = api.size([0, 1])[1];
        const state = api.value(3);
        if (!start || !end) return;

        const rectShape = echarts.graphic.clipRectByRect({
            x: start[0],
            y: start[1] - height / 2,
            width: end[0] - start[0],
            height: height
        }, {
            x: params.coordSys.x,
            y: params.coordSys.y,
            width: params.coordSys.width,
            height: params.coordSys.height
        });

        return rectShape && {
            type: 'rect',
            transition: ['shape'],
            shape: rectShape,
            style: {
                fill: stateColors[state] || '#ced4da',
                text: state,
                textFill: '#fff',
                textPosition: 'inside',
                fontWeight: 'bold',
                fontSize: 10,
            }
        };
    }

    const option = {
        tooltip: {
            formatter: function (params) {
                // Timezone fonksiyonunu kullanmak için burada güncellendi
                const state = params.value[3];
                const start = formatTimeForTimezone(params.value[1], 'full');
                const end = formatTimeForTimezone(params.value[2], 'full');
                return `${nodeNames[params.value[0]]}<br/><b>${state}</b><br/>${start} - ${end}`;
            }
        },
        legend: {
          show: true, data: legendData, bottom: 0, type: 'scroll'
        },
        grid: {
            height: nodeNames.length * 40, top: 20, bottom: 60,
            left: 20, right: 50, containLabel: true,
        },
        xAxis: {
            type: 'time',
            min: new Date(labels[0]).getTime(),
            max: new Date(labels[labels.length - 1]).getTime(),
            axisLabel: { 
                // Timezone fonksiyonunu kullanmak için güncellendi
                formatter: function(value) {
                    return formatTimeForTimezone(value, 'short', totalDurationHours);
                }
            }
        },
        yAxis: {
            type: 'category', data: nodeNames, axisLabel: { interval: 0 }
        },
        series: [{
            type: 'custom', renderItem: renderItem, itemStyle: { opacity: 0.9 },
            encode: { x: [1, 2], y: 0 }, data: chartData
        }]
    };
    myChart.setOption(option);
  }

  const getConfigVal = (path, fallback = 'N/A') => {
    try {
      const value = path.split('.').reduce((o, k) => o[k], globalData.config);
      if (typeof value === 'object' && value !== null) {
        if ('$numberInt' in value) return value['$numberInt'];
        if ('$numberLong' in value) return value['$numberLong'];
      }
      return value ?? fallback;
    } catch (e) {
      return fallback;
    }
  };

  function buildSummaryViewer(config, configChanged) {
    if (!config) return null;

    const section = document.createElement('div');
    section.className = 'section';
    
    const title = document.createElement('div');
    title.className = 'sec-title';
    title.textContent = 'Host & Configuration Summary';
    
    const content = document.createElement('div');
    content.className = 'summary-container'; 

    content.innerHTML = `
      <div class="summary-grid">
        <div class="summary-section">
          <h3>Version & Build</h3>
          <ul>
            <li><span>Hostname:</span> <span>${getConfigVal('hostInfo.system.hostname')}</span></li>
            <li><span>Mongo Version:</span> <span>${getConfigVal('buildInfo.version')} (${(getConfigVal('buildInfo.modules.0', ''))})</span></li>
            <li><span>OS:</span> <span>${getConfigVal('hostInfo.os.name')}</span></li>
            <li><span>Git Version:</span> <span>${getConfigVal('buildInfo.gitVersion')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Network & Replication</h3>
          <ul>
            <li><span>IP Addresses:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.bindIp')}</span></li>
            <li><span>Port:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.port')}</span></li>
            <li><span>Replica Set:</span> <span>${getConfigVal('getCmdLineOpts.parsed.replication.replSetName', 'Not in a replicaset')}</span></li>
            <li><span>Security:</span> <span>${getConfigVal('getCmdLineOpts.parsed.security.clusterAuthMode', 'N/A')}</span></li>
            <li><span>TLS Mode:</span> <span>${getConfigVal('getCmdLineOpts.parsed.net.tls.mode', 'disabled')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Storage & Logging</h3>
          <ul>
            <li><span>Data Path (dbPath):</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.dbPath')}</span></li>
            <li><span>Log Path:</span> <span>${getConfigVal('getCmdLineOpts.parsed.systemLog.path')}</span></li>
            <li><span>Journaling:</span> <span>${getConfigVal('getCmdLineOpts.parsed.storage.journal.enabled', 'false')}</span></li>
          </ul>
        </div>
        <div class="summary-section">
          <h3>Server & Limits</h3>
          <ul>
            <li><span>CPU:</span> <span>${getConfigVal('hostInfo.system.numCores')} Cores</span></li>
            <li><span>CPU Arch:</span> <span>${getConfigVal('hostInfo.system.cpuArch')}</span></li>
            <li><span>RAM:</span> <span>${getConfigVal('hostInfo.system.memSizeMB')} MB</span></li>
            <li><span>Open Files Limit:</span> <span>${getConfigVal('ulimits.fileDescriptors.soft')}</span></li>
          </ul>
        </div>
      </div>
      <div>
        <details class="config-details">
          <summary class="config-summary">
            Active Configuration (parsed)
            ${configChanged ? '<span class="config-change-dot" title="Configuration changed during this period">●</span>' : ''}
          </summary>
          <pre class="config-view">${JSON.stringify(getConfigVal('getCmdLineOpts.parsed', {}), null, 2)}</pre>
        </details>
      </div>
    `;

    section.appendChild(title);
    section.appendChild(content);

    title.addEventListener('click', () => {
      title.classList.toggle('collapsed');
      const isCollapsed = title.classList.contains('collapsed');
      content.style.maxHeight = isCollapsed ? '0px' : (content.scrollHeight + 'px');
    });

    return section;
  }
  
  function buildCustomMetricsChart() {
    const section = document.createElement('div');
    section.className = 'section';
    const secTitle = document.createElement('div');
    secTitle.className = 'sec-title';
    secTitle.textContent = 'Custom metrics';
    section.appendChild(secTitle);

    const card = document.createElement('div');
    card.className = 'card custom-metrics-card';
    const keys = globalData.keys || [];
    const chartLabels = (globalData.labels || []).map(ts => new Date(ts).getTime());
    const totalDurationHours = (chartLabels.length > 1) ? (chartLabels[chartLabels.length - 1] - chartLabels[0]) / (1000 * 60 * 60) : 0;
    const palette = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#0ea5e9','#f97316','#22c55e','#e11d48','#10b981','#a855f7','#84cc16'];

    card.innerHTML = `
      <div class="pane">
        <div class="title">Select metrics to plot</div>
        <div class="metrics-selector">
          <details>
            <summary>Metrics (${keys.length} total) — click to select</summary>
            <div class="metrics-dropdown" id="custom-metrics-checkboxes"></div>
          </details>
        </div>
        <div class="chart custom-metrics-chart" id="custom-metrics-chart"></div>
      </div>
    `;
    section.appendChild(card);

    const checkboxContainer = card.querySelector('#custom-metrics-checkboxes');
    const chartDom = card.querySelector('#custom-metrics-chart');

    const selectedKeys = new Set();
    keys.forEach(key => {
      const label = document.createElement('label');
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.dataset.key = key;
      input.addEventListener('change', () => {
        if (input.checked) selectedKeys.add(key); else selectedKeys.delete(key);
        updateCustomChart();
      });
      label.appendChild(input);
      label.appendChild(document.createTextNode(key));
      checkboxContainer.appendChild(label);
    });

    function updateCustomChart() {
      const arr = Array.from(selectedKeys);
      if (arr.length === 0) {
        myChart.setOption({ series: [], xAxis: { type: 'time' }, yAxis: { type: 'value' } }, { notMerge: true });
        return;
      }
      const series = arr.map((key) => {
        const raw = globalData.series[key] || [];
        const data = [];
        for (let i = 0; i < raw.length; i++) {
          const t = chartLabels[i];
          const v = raw[i];
          if (t != null && typeof v === 'number' && !Number.isNaN(v)) data.push([t, v]);
        }
        return { name: key, type: 'line', data, smooth: true, showSymbol: false, lineStyle: { width: 2 }, emphasis: { focus: 'series' }, connectNulls: true };
      });
      myChart.setOption({
        color: palette,
        tooltip: { trigger: 'axis', confine: true, formatter: function(params) {
          if (!params || params.length === 0) return '';
          let output = formatTimeForTimezone(params[0].value[0], 'full');
          params.forEach(param => { output += `<br/><span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: ${(param.value[1] != null && !Number.isNaN(param.value[1]) ? param.value[1].toFixed(2) : '—')}`; });
          return output;
        }},
        legend: { show: true, type: 'scroll', bottom: 0 },
        grid: { left: 55, right: 25, top: 40, bottom: 36, containLabel: false },
        xAxis: { type: 'time', axisLabel: { hideOverlap: true, formatter: function(value) { return formatTimeForTimezone(value, 'short', totalDurationHours); } } },
        yAxis: { type: 'value', axisLine: { show: false }, splitLine: { lineStyle: { color: '#e5e7eb' } }, axisLabel: { formatter: v => (v != null && !Number.isNaN(v) ? v.toFixed(2) : '—') } },
        series
      }, { notMerge: true, replaceMerge: ['series'] });
      myChart.resize();
    }

    secTitle.addEventListener('click', () => {
      secTitle.classList.toggle('collapsed');
      const isCollapsed = secTitle.classList.contains('collapsed');
      card.style.maxHeight = isCollapsed ? '0' : 'none';
      card.style.overflow = isCollapsed ? 'hidden' : 'visible';
    });

    W.appendChild(section);
    const myChart = echarts.init(chartDom);
  }

  buildCustomMetricsChart();

  const summaryEl = buildSummaryViewer(globalData.config, globalData.config_changed);
  if (summaryEl) {
    W.appendChild(summaryEl);
    const content = summaryEl.querySelector('.summary-container');
    if (content) {
      content.style.maxHeight = content.scrollHeight + 'px';
    }
  }

  const replChartContainerEl = buildReplStatusChartContainer(globalData.repl_timeline);
  if (replChartContainerEl) {
    W.appendChild(replChartContainerEl);
    initReplStatusChart(replChartContainerEl, globalData.repl_timeline, globalData.labels);
  }

  const gRepl = buildSection('Replication');
  const replLagKeys = (globalData.keys || []).filter(k => k.startsWith('repl_lag_sec_'));
  if (replLagKeys.length) buildCard(gRepl, 'Replication lag (per secondary)', replLagKeys, 'sec', true);

  function stats(arr){
    const vals = (arr||[]).filter(v => typeof v === 'number' && !Number.isNaN(v));
    if (!vals.length) return {min:null,max:null,avg:null,p95:null};
    vals.sort((a, b) => a - b);
    const p95Index = Math.floor(vals.length * 0.95);
    const p95 = vals[p95Index];
    let min=vals[0], max=vals[vals.length - 1], sum=0;
    for (const v of vals){ sum+=v; }
    return {min, max, avg: sum/vals.length, p95};
  }

  function fmt(v){
    if (v == null || typeof v !== 'number' || Number.isNaN(v)) return '—';
    return v.toFixed(2);
  }

  function buildSection(title){ 
    const s = document.createElement('div'); 
    s.className='section';
    const secTitle = document.createElement('div');
    secTitle.className = 'sec-title';
    secTitle.textContent = title;
    const grid = document.createElement('div');
    grid.className = 'grid';
    s.appendChild(secTitle);
    s.appendChild(grid);
    W.appendChild(s);

    secTitle.addEventListener('click', () => {
      secTitle.classList.toggle('collapsed');
      const isCollapsed = secTitle.classList.contains('collapsed');
      grid.style.maxHeight = isCollapsed ? '0px' : (grid.scrollHeight + 'px');
    });
    return grid; 
  }

  function getDisplayName(key, title) {
      if (title.toLowerCase().includes('disk')) {
        const parts = key.split('_');
        const device = parts[parts.length - 1];
        if (key.includes('_read_')) return `${device} (read)`;
        if (key.includes('_write_')) return `${device} (write)`;
        return device;
      }
      if (key.startsWith('wt_pages_evicted_')) {
        return key.includes('_modified_') ? 'modified' : 'unmodified';
      }
      if (key.startsWith('repl_lag_sec_')) {
        return key.replace(/^repl_lag_sec_/, '');
      }
      return key;
  }

  function buildCard(grid, title, seriesKeys, unit, wide){
    // globalData.series'i kullan
    if (!seriesKeys || !seriesKeys.some(k => globalData.series[k])) return;
    const card = document.createElement('div');
    card.className = 'card' + (wide ? ' wide-card' : '');
    card.innerHTML = `<div class="pane"><div class="title">${title}</div><div class="chart"></div></div><div class="tablewrap"><div class="actions"><span class="chip">series</span><button class="btn" data-act="all">All</button><button class="btn" data-act="none">None</button><button class="btn" data-act="inverse">Inverse</button></div><table class="tbl"><thead><tr><th class="sortable asc" data-k="name">name</th><th class="sortable" data-k="min">min</th><th class="sortable" data-k="avg">avg</th><th class="sortable" data-k="max">max</th><th class="sortable" data-k="p95">p95</th></tr></thead><tbody></tbody></table></div>`;
    grid.appendChild(card);
    
    // Zaman damgalarını milisaniye olarak al
    const chartLabels = L.map(ts => new Date(ts).getTime());
    
    const cardDurationHours = (chartLabels && chartLabels.length > 1) 
        ? (chartLabels[chartLabels.length - 1] - chartLabels[0]) / (1000 * 60 * 60) 
        : 0;

    const chart = echarts.init(card.querySelector('.chart'), 'light', {renderer:'canvas'});
    const palette = ['#2563eb','#16a34a','#f59e0b','#ef4444','#8b5cf6','#0ea5e9','#f97316','#22c55e','#e11d48','#10b981','#a855f7','#84cc16'];
    const legendSelected = {};
    const series = seriesKeys.map((key, i) => {
      const displayName = getDisplayName(key, title);
      legendSelected[displayName] = true;
      // globalData.series[key]'i kullan
      const seriesData = (globalData.series[key] || []).map((val, index) => {
        return [chartLabels[index], val];
      });
      return { name: displayName, key: key, type:'line', data: seriesData, smooth: true, showSymbol:false, lineStyle:{width:2}, emphasis:{focus:'series'}, connectNulls:false };
    });

    // Option ayarları Timezone fonksiyonlarını kullanacak şekilde güncellendi
    chart.setOption({
      tooltip:{ 
        trigger:'axis', 
        confine:true, 
        // Tam kontrol için formatter'ı ayarla
        formatter: function(params) {
              if (params.length === 0) return '';
              let output = formatTimeForTimezone(params[0].value[0], 'full'); // X eksenindeki zamanı formatla
              params.forEach(param => {
                  output += `<br/><span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: ${fmt(param.value[1])} ${unit||''}`;
              });
              return output;
        }
      },
      color: palette, 
      legend:{ show:false, selected: legendSelected },
      grid:{ left:55,right:25,top:40,bottom:36,containLabel:false },
      xAxis:{ 
        type:'time', 
        axisLabel:{ 
          hideOverlap: true, 
          // Timezone fonksiyonunu kullanmak için güncellendi
          formatter: function(value) {
            return formatTimeForTimezone(value, 'short', cardDurationHours);
          }
        } 
      },
      yAxis:{ type:'value', axisLine:{show:false}, splitLine:{lineStyle:{color:'#e5e7eb'}}, axisLabel: { formatter: (v) => fmt(v) } },
      series
    });

    const tbody = card.querySelector('tbody');
    const thead = card.querySelector('thead');
    const btns = card.querySelectorAll('.actions .btn');
    let rows = seriesKeys.map((key, i) => {
      // globalData.series[key]'i kullan
      const arr = globalData.series[key] || [];
      const st = stats(arr);
      return { key: key, displayName: getDisplayName(key, title), idx:i, color: palette[i % palette.length], min: st.min, max: st.max, avg: st.avg, p95: st.p95, on: true };
    });
    let sortState = {k:'name', asc:true};

    function renderRows(){
      const k = sortState.k;
      rows.sort((a,b) => {
        if (k==='name') return sortState.asc ? a.displayName.localeCompare(b.displayName) : b.displayName.localeCompare(a.displayName);
        const av = a[k]; const bv = b[k];
        if (av==null && bv==null) return 0;
        if (av==null) return 1;
        if (bv==null) return -1;
        return sortState.asc ? (av-bv) : (bv-av);
      });
      tbody.innerHTML='';
      for (const r of rows){
        const tr = document.createElement('tr');
        tr.className = r.on ? '' : 'off';
        tr.dataset.key = r.key;
        tr.innerHTML = `<td class="namecell"><span class="dot" style="background:${r.color}"></span><span>${r.displayName}</span></td><td>${fmt(r.min)} ${unit||''}</td><td>${fmt(r.avg)} ${unit||''}</td><td>${fmt(r.max)} ${unit||''}</td><td>${fmt(r.p95)} ${unit||''}</td>`;
        tr.addEventListener('click', (ev) => {
          const isolate = ev.metaKey || ev.ctrlKey;
          if (isolate){
            for (const rr of rows){ rr.on = (rr.key === r.key); legendSelected[rr.displayName] = rr.on; }
          } else { r.on = !r.on; legendSelected[r.displayName] = r.on; }
          chart.setOption({legend:{selected:legendSelected}});
          renderRows();
        });
        tbody.appendChild(tr);
      }
    }
    renderRows();

    thead.querySelectorAll('th.sortable').forEach(th=>{
      th.addEventListener('click', ()=>{
        const k = th.dataset.k;
        if (sortState.k===k){ sortState.asc = !sortState.asc; } else { sortState.k=k; sortState.asc = (k==='name'); }
        thead.querySelectorAll('th').forEach(x=>x.classList.remove('asc'));
        if (sortState.asc) th.classList.add('asc');
        renderRows();
      });
    });
    btns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const act = btn.dataset.act;
        if (act==='all'){ rows.forEach(r=>{ r.on=true; legendSelected[r.displayName]=true; }); } 
        else if (act==='none'){ rows.forEach(r=>{ r.on=false; legendSelected[r.displayName]=false; }); }
        else if (act==='inverse'){ rows.forEach(r=>{ r.on=!r.on; legendSelected[r.displayName]=r.on; }); }
        chart.setOption({legend:{selected:legendSelected}});
        renderRows();
      });
    });

    window.addEventListener('resize', () => {
        document.querySelectorAll('.chart, .repl-chart').forEach(c => echarts.getInstanceByDom(c)?.resize());
        document.querySelectorAll('.sec-title:not(.collapsed) + .grid, .summary-container').forEach(grid => {
          if (grid.style.maxHeight !== '0px') {
            grid.style.maxHeight = grid.scrollHeight + 'px';
          }
        });
    });

    return card;
  }
  
  const gMongo = buildSection('Mongo');
  buildCard(gMongo, 'Connections', ['connections_created_per_sec','connections_current','connections_available'], '');
  buildCard(gMongo, 'Opcounters (per sec)', ['opcounters_query_per_sec','opcounters_insert_per_sec','opcounters_update_per_sec','opcounters_delete_per_sec','opcounters_command_per_sec'], '');
  buildCard(gMongo, 'Documents (per sec)', ['docs_returned_per_sec','docs_inserted_per_sec','docs_updated_per_sec','docs_deleted_per_sec'], '');
  buildCard(gMongo, 'Op Latency (avg µs)', ['latency_reads_avg_ms','latency_writes_avg_ms','latency_commands_avg_ms'], 'µs');
  buildCard(gMongo, 'Query Executor (per sec)', ['query_scanned_keys_per_sec','query_scanned_objects_per_sec','query_collection_scans_total_per_sec','query_collection_scans_nontailable_per_sec'], '');
  buildCard(gMongo, 'TTL (per sec)', ['ttl_passes_per_sec','ttl_deletedDocuments_per_sec'], '');

  const gWT = buildSection('WiredTiger');
  buildCard(gWT, 'Cache (MB)', ['wt_cache_bytes_in_cache_mb','wt_cache_dirty_bytes_mb','wt_cache_max_bytes_mb'], 'MB');
  buildCard(gWT, 'IO (MB/s)', ['wt_read_mb_per_sec','wt_write_mb_per_sec'], 'MB/s');
  buildCard(gWT, 'Cache Pages Evicted (per sec)', ['wt_pages_evicted_modified_per_sec', 'wt_pages_evicted_unmodified_per_sec'], 'pages/s');
  buildCard(gWT, 'Tickets', ['wt_tickets_avail_read','wt_tickets_avail_write'], '');

  const gOS = buildSection('OS');
  // Eski kodunuzdaki OS metrikleri kullanıldı
  buildCard(gOS, 'CPU (%)', ['cpu_user_percent','cpu_system_percent','cpu_iowait_percent','cpu_softirq_percent','cpu_nice_percent','cpu_idle_percent'], '%');
  buildCard(gOS, 'Memory (MB)', ['sys_mem_available_mb','sys_mem_total_mb'], 'MB');
  buildCard(gOS, 'Network (MB/s)', ['network_bytes_in_per_sec','network_bytes_out_per_sec'], 'MB/s');
  // Load Average/Diskler için eski kodunuzdaki tanımlamalar kullanıldı
  
  const gDisk = buildSection('OS / Disks');
  const allKeys = Object.keys(globalData.series);
  const iopsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_iops_') || k.includes('_write_iops_')));
  const mbpsKeys    = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_mbps_') || k.includes('_write_mbps_')));
  const latKeys     = allKeys.filter(k => k.startsWith('disk_') && (k.includes('_read_latency_ms_') || k.includes('_write_latency_ms_')));
  const utilKeys    = allKeys.filter(k => k.startsWith('disk_') && k.includes('_utilization_percent_'));
  const queueKeys   = allKeys.filter(k => k.startsWith('disk_') && k.includes('_queue_depth_avg_'));
  buildCard(gDisk, 'Disk IOPS (per device)', iopsKeys, 'iops');
  buildCard(gDisk, 'Disk Throughput (MB/s per device)', mbpsKeys, 'MB/s');
  buildCard(gDisk, 'Disk Latency (ms per device)', latKeys, 'ms');
  buildCard(gDisk, 'Disk Utilization (% per device)', utilKeys, '%');
  buildCard(gDisk, 'Disk Queue Depth (avg per device)', queueKeys, '');

  // Initialize section collapsed states
  document.querySelectorAll('.grid').forEach(grid => {
    grid.style.maxHeight = grid.scrollHeight + 'px';
  });
})();
</script>
</body>
</html>
